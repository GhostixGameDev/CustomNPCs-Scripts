//Globals
//STATS
var HP=800000
var HPRegen=5000
var startPoint=[1812,66,1218]
var meleeDamage=14000
var rangedDamage=10000
//Transformation variables
var transformationName = "Yurin"
var transformationCloneTab = 1
//Stun
var hitsToStun = [5,9] //This is a range. So between 3-5 hits.
var stunDuration = 140 //ticks
var npcImmuneWhenNotStunned = true

var stunSound = "jinryuudragonbc:DBC2.strongpunch"

//Transformation
var transforming=false
var regenSpeed = 5 //ticks
var regenAmount = 3 //hp
var transformSound = "jinryuudragonbc:DBC.powerup"
var attackBounceSound = "jinryuudragonbc:DBC4.block2" //sound that plays if the player tries to damage the npc while regenering
var useAbilityOnlyOnce = true

//clones
var clone = "tienClone"
var cloneSound = "jinryuudragonbc:1610.sse"
var DoneAbility;
//Functions
//Transformation
function transform(npc){
    transforming=true
    npc.setTempData("lastTarget",npc.getAttackTarget())
    npc.executeCommand("playsound " + transformSound + " @p" + " 0 0 0 1 0 1")
    npc.timers.forceStart(18,regenSpeed,true)
    npc.setRetaliateType(3)
}
function makeClones(npc, surroundingPlayers){
    var surroundingPlayersAmount = surroundingPlayers.length
    for(var i=0; i<6; i++){
        for(var j=0; j<surroundingPlayersAmount;j++){
           playSound(npc, cloneSound, surroundingPlayers[j])
        }
        npc.executeCommand("kamkeel clone spawn " + clone + " " + transformationCloneTab)
    }
}
//Stun and unstun.
function stun(npc, surroundingPlayers){
    var surroundingPlayersAmount = surroundingPlayers.length
    for(var i=0; i<surroundingPlayersAmount;i++){
        playSound(npc, attackBounceSound, surroundingPlayers[i])
    }
    npc.timers.forceStart(17,stunDuration,false)
}

function unStun(npc){
    npc.say("NO ME VENCERAS TAN FACIL!")
}
function playSound(npc, sound, player){
    npc.executeCommand("playsound " + sound + " " + player.getName() +" 0 0 0 1 0 1")
}
function getSurroundingPlayers(npc){
    var surroundingPlayers = npc.getSurroundingEntities(npc.getAggroRange(), 1)
    npc.setTempData("lastSurroundingPlayers", surroundingPlayers)
    return surroundingPlayers;
}
function partyStatsAdjuster(npc, multiplier) {
    // Ensure HP and other relevant stats are defined and valid numbers
    if (typeof HP !== 'number' || isNaN(HP) || HP <= 0) {
        return; // Exit if HP is not valid
    }
    if (typeof HPRegen !== 'number' || isNaN(HPRegen) || HPRegen < 0) {
        return; // Exit if HPRegen is not valid
    }
    if (typeof meleeDamage !== 'number' || isNaN(meleeDamage) || meleeDamage < 0) {
        return; // Exit if meleeDamage is not valid
    }
    if (typeof rangedDamage !== 'number' || isNaN(rangedDamage) || rangedDamage < 0) {
        return; // Exit if rangedDamage is not valid
    }

    var surroundingPlayers = getSurroundingPlayers(npc);
    var surroundingPlayersAmount = surroundingPlayers.length;

    // Update stats only if the number of surrounding players is greater than 1
    if (surroundingPlayersAmount > 1) {
        var newMaxHealth = HP * surroundingPlayersAmount * multiplier;
        var newHealthRegen = HPRegen * surroundingPlayersAmount * (multiplier - 0.5);
        var newMeleeStrength = meleeDamage * surroundingPlayersAmount * (multiplier - 0.5);
        var newRangedStrength = rangedDamage * surroundingPlayersAmount * (multiplier - 0.5);

        if (!isNaN(newMaxHealth) && !isNaN(newHealthRegen) && !isNaN(newMeleeStrength) && !isNaN(newRangedStrength)) {
            var currentHealth = npc.getHealth();
            var maxHealth = npc.getMaxHealth();

            // Proportionally adjust current health
            var newCurrentHealth = (currentHealth / maxHealth) * newMaxHealth;

            npc.setMaxHealth(newMaxHealth);
            npc.setHealth(newCurrentHealth);
            npc.setHealthRegen(newHealthRegen);
            npc.setMeleeStrength(newMeleeStrength);
            npc.setRangedStrength(newRangedStrength);
            npc.setTempData("statsAdjustedToPlayers", 1);
        }
    } else {
        // Reset to default stats if only one player is around
        var currentHealth = npc.getHealth();
        var maxHealth = npc.getMaxHealth();

        // Proportionally adjust current health
        var newCurrentHealth = (currentHealth / maxHealth) * HP;

        npc.setMaxHealth(HP);
        npc.setHealth(newCurrentHealth);
        npc.setHealthRegen(HPRegen);
        npc.setMeleeStrength(meleeDamage);
        npc.setRangedStrength(rangedDamage);
        npc.removeTempData("statsAdjustedToPlayers");
    }

    // Update the last surrounding players amount
    npc.setTempData("lastSurroundingPlayers", surroundingPlayersAmount);
}





//Initial events
function init(t){
    //Stats initializer.
    t.npc.setHome(startPoint[0],startPoint[1],startPoint[2])
    t.npc.setPosition(startPoint[0],startPoint[1],startPoint[2])
    t.npc.setMaxHealth(HP)
    t.npc.setHealth(HP)
    t.npc.setHealthRegen(HPRegen)
    t.npc.setMeleeStrength(meleeDamage)
    t.npc.setRangedStrength(rangedDamage)
    //Shield and Skill
    t.npc.setTempData("shielded",1)
    t.npc.removeTempData("skillUsed")
    //Stun initializer
    t.npc.setTempData("hitsNeeded",Math.round(Math.random()*(hitsToStun[1]-hitsToStun[0]))+hitsToStun[0])
    t.npc.setTempData("hitsTaken",0)
    DoneAbility = false
}
//Events per tick
function tick(t){

    //AI
    if(t.npc.isAttacking()){
        var targ = t.npc.getAttackTarget()
        var ClosestPlayer
        if(targ.getType() != 1){
        ClosestPlayer = t.npc.world.getClosestEntity(t.npc.getPos(),t.npc.getAggroRange(),3)
        if(targ != ClosestPlayer){
            //t.npc.say("Changing target to:"+ClosestPlayer)
            t.npc.setAttackTarget(ClosestPlayer)
            }
        }
        //Stats adjuster
        partyStatsAdjuster(t.npc, 1)
    }
    
}
function damaged(t){
    //uncomment this is you wanna know the damage type of something
    //t.npc.say(t.damageSource.getType())
    //Stun
    var taken = t.npc.getTempData("hitsTaken")
    var needed = t.npc.getTempData("hitsNeeded")
    var surroundingPlayers = getSurroundingPlayers(t.npc)
    var surroundingPlayersAmount = surroundingPlayers.length
    taken = taken + 1
    if(taken >= needed ){
        stun(t.npc, surroundingPlayers)
        t.npc.setTempData("hitsNeeded",(Math.round(Math.random()*(hitsToStun[1]-hitsToStun[0]))+hitsToStun[0]))
        taken = 0;
    }
    t.npc.setTempData("hitsTaken",taken)
    if(npcImmuneWhenNotStunned && !t.npc.timers.has(17) && transforming!=true){
        
        for(var i=0; i<surroundingPlayersAmount;i++){
            playSound(t.npc, attackBounceSound, surroundingPlayers[i])
        }
        t.setCanceled(true)
    }
    //Clone
    //Make a check for if the NPC health is low enough, AND the global variable for the ability is false
    if(t.npc.getHealth()-t.damage <= t.npc.getMaxHealth()*0.50 && !DoneAbility){
        DoneAbility = true
        makeClones(t.npc, surroundingPlayers)
    }
    //Transform
    if(t.npc.hasTempData("skillUsed")) return;
    if(t.npc.timers.has(18)){
        for(var i=0; i<surroundingPlayersAmount;i++){
            playSound(t.npc, attackBounceSound, surroundingPlayers[i])
        }
        t.setCanceled(true)
        return;
    }
    if(t.npc.getHealth() - t.damage <= 0){
        t.damage = 0
        t.npc.setHealth(1)
        transform(t.npc)
    }
}

//Timers/Temporizadores
function timer(t){
    //Stun timer.
    if(t.id == 17 && transforming!=true){
        unStun(t.npc)}
    //Transformation.
    if(t.id == 18){
        t.npc.say("Q-Que?");
        t.npc.executeCommand("kamkeel clone spawn " + transformationName + " " + transformationCloneTab)
        t.npc.despawn()
    }
    
}






